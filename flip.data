#version 330

// Input vertex attributes (from vertex shader)
in vec3 fragColor;
in float fragDrawDisk;

// Output fragment color
out vec4 finalColor;

void main()
{
    if (fragDrawDisk == 1.0) {
        float rx = 0.5 - gl_PointCoord.x;
        float ry = 0.5 - gl_PointCoord.y;
        float r2 = rx * rx + ry * ry;
        if (r2 > 0.25)
            discard;
    }
    
    finalColor = vec4(0.0, 1.0, 1.0, 1.0);
}#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexColor;

// Output vertex attributes
out vec3 fragColor;
out float fragDrawDisk;

// Uniform locations
uniform mat4 mvp;
uniform vec2 domainSize;
uniform float pointSize;
uniform float drawDisk;

void main()
{
    // Position with custom transform (you may want to use mvp instead depending on your needs)
    vec4 position = mvp * vec4(vertexPosition.xy, 0.0, 1.0);
    
    // Alternative using raylib's mvp matrix:
    // vec4 position = mvp * vec4(vertexPosition, 1.0);
    
    gl_Position = position;
    gl_PointSize = pointSize;
    
    // Pass to fragment shader
    fragColor = vertexColor;
    fragDrawDisk = drawDisk;
}#version 100
precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec3 fragColor;
varying float fragDrawDisk;

// Output fragment color
// Note: In WebGL/GLSL 100, we don't declare outputs with 'out'

void main()
{
    if (fragDrawDisk > 0.9) {  // Using approx comparison for floating point
        float rx = 0.5 - gl_PointCoord.x;
        float ry = 0.5 - gl_PointCoord.y;
        float r2 = rx * rx + ry * ry;
        
        if (r2 > 0.25)
            discard;
    }
    
    gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);
}#version 100

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexColor;

// Output vertex attributes (to fragment shader)
varying vec3 fragColor;
varying float fragDrawDisk;

// Uniform locations
uniform mat4 mvp;
uniform vec2 domainSize;
uniform float pointSize;
uniform float drawDisk;

void main()
{
    // Position with custom transform
    vec4 position = mvp * vec4(vertexPosition.xy, 0.0, 1.0);
    
    // Alternative using raylib's mvp matrix:
    // vec4 position = mvp * vec4(vertexPosition, 1.0);
    
    gl_Position = position;
    gl_PointSize = pointSize;
    
    // Pass to fragment shader
    fragColor = vertexColor;
    fragDrawDisk = drawDisk;
}